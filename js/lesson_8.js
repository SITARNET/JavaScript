// Arrays — Part 1st (Arrays and array processing)

// 1. Вступление
// Массив – это упорядоченная коллекция значений. Значения в массиве называются элементами, и каждый элемент характеризуется числовой позицией
// (или строкой если речь идет о ассоциативных массивах) в массиве, которая называется индексом (ключ для ассоциативных).
// Массивы в языке JavaScript являются нетипизированными: элементы массива могут иметь любой тип, причем разные элементы одного и того
// же массива могут иметь разные типы. Элементы массива могут даже быть объектами или другими массивами, что позволяет создавать сложные
// структуры данных, такие как массивы объектов и массивы массивов.
// В JavaScript есть 2 типа массивов: ассоциативные массивы и массивы с числовыми индексами.
// Ассоциативные массивы в JavaScript это не отдельный тип коллекции, а всего лишь объекты без методов.
// То есть если объект хранит данные и не делает с ними никаких действий это ассоциативный массив.
// В отличии от ассоциативных массивов, массивы с числовыми индексами в JavaScript считаются отдельной кастой (говорят подкласом) обычных объектов.
// Но не образуют отдельного типа данных как в других языках програмирования.

// 2. Объекты как ассоциативные массивы
// В этой главе мы рассмотрим использование объектов именно как массивов.
// Ассоциативные массивы - структура данных, в которой можно хранить любые данные в формате ключ-значение.
// Именно синтаксис доступа к полям объекта через квадратные скобки делает их похожими на ассоциативные массивы других языков програмирования.
// Так как ассоциативные массивы это просто объекты, все методики работы с объектами справедливы и к ассоциативным массивам.
// Могут закрасться сомнения нужно ли вводить такой термин как ассоциативные массивы, для JS колекций если это всего лишь объекты,
// но стоит знать что ассоциативные массивы имеют некие механизмы оптимизации, что приводит к отличиям реализаций таких структур на уровне памяти.
// А именно ассоциативные массивы поддерживают механизм компактного представления в памяти.

// 3. Массивы с числовыми индексами
// В этой главе мы рассмотрим использование подкласса Array - что реализовывает массивы с числовыми индексами в JavaScript.
// С этого момента и в будущем массивы с числовыми индексами мы будем называть просто массивами.
// Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для
// удобного манипулирования такой коллекцией.
// Отсчет индексов массивов в языке JavaScript начинается с нуля и для них используются 32-битные целые числа: первый элемент
// массива имеет индекс 0, а наибольший возможный индекс имеет значение 4294967295 элементов.

// 4. Создание массивов
// Легче всего создать массив с помощью литерала, который представляет собой простой список разделенных запятыми элементов массива в квадратных скобках.

// 'use strict';
// var empty = []; // Пустой массив
// var primes = [2, 3, 5, 7, 11]; // Массив с пятью числовыми элементами
// var misc = [ 1.1, true, "a" ]; // 3 элемента разных типов

// Значения в литерале массива не обязательно должны быть константами – это могут быть любые выражения:

// var base = 1024;
// var table = [base, base+1, base+2, base+3];

// Литералы массивов могут содержать литералы объектов или литералы других массивов:

// var b = [[1,{x:1, y:2}], [2, {x:3, y:4}]];

// Другой способ создания массива состоит в вызове конструктора Array(). Вызвать конструктор можно тремя разными способами:

// Вызвать конструктор без аргументов:
// var a = new Array();

// В этом случае будет создан пустой массив, эквивалентный литералу [].

// Вызвать конструктор с единственным числовым аргументом,
// определяющим длину массива:
// var a = new Array(10);

// В этом случае будет создан пустой массив указанной длины. Такая форма вызова конструктора Array() может использоваться для
// предварительного распределения памяти под массив, если заранее известно количество его элементов. Обратите внимание,
// что при этом в массиве не сохраняется никаких значений и даже свойства-индексы массива с именами «0», «1» и т.д. в массиве не определены.

// Явно указать в вызове конструктора значения первых двух или более
// элементов массива или один нечисловой элемент:
// var a = new Array(5, 4, 3, 2, 1, "testing, testing");

// В этом случае аргументы конструктора становятся значениями элементов нового массива. Использование литералов массивов практически всегда проще,
// чем подобное применение конструктора Array().

// 5. Доступ к элементам массива
// Доступ к элементам массива осуществляется с помощью оператора [ ]. Слева от скобок должна присутствовать ссылка на массив.
// Внутри скобок должно находиться произвольное выражение, возвращающее неотрицательное целое значение. Этот синтаксис пригоден как для чтения,
// так и для записи значения элемента массива. Следовательно, допустимы все приведенные далее JavaScript-инструкции:

// var a = ["world"]; // Создать массив с одним элементом
// var value = a[0]; // Прочитать элемент 0
// a[1] = 3.14; // Записать значение в элемент 1
// var i = 2;
// a[i] = 3; // Записать значение в элемент 2
// a[i + 1] = "hello"; // Записать значение в элемент 3
// a[a[i]] = a[0]; // Прочитать элементы 0 и 2, записать значение в элемент 3

// Напомню, что массивы являются специализированной разновидностью объектов. Квадратные скобки, используемые для доступа к элементам массива,
// действуют точно так же, как квадратные скобки, используемые для доступа к свойствам объекта. Интерпретатор JavaScript преобразует указанные
// в скобках числовые индексы в строки – индекс 1 превращается в строку "1", – а затем использует строки как имена свойств. В преобразовании
// числовых индексов в строки нет ничего особенного: то же самое можно проделывать с обычными объектами.

// 8.2 ES5
// Стандарт ECMAScript 5 определяет девять новых методов массивов, позволяющих выполнять итерации, отображение, фильтрацию, проверку, свертку и поиск.
// Все эти методы описываются в следующих далее подразделах.
// Однако, прежде чем перейти к изучению особенностей, следует сделать некоторые обобщения, касающиеся методов массивов в ECMAScript 5.
// Во-первых, большинство описываемых ниже методов принимают функцию в первом аргументе и вызывают ее для каждого элемента
// (или нескольких элементов) массива. В случае разреженных массивов указанная функция не будет вызываться для несуществующих элементов.
// В большинстве случаев указанной функции передаются три аргумента: значение элемента массива, индекс элемента и сам массив.
// Чаще всего вам необходим будет только первый аргумент, а второй и третий аргументы можно просто игнорировать.
// Большинство методов массивов, введенных стандартом ECMAScript 5, которые в первом аргументе принимают функцию, также принимают
// второй необязательный аргумент. Если он указан, функция будет вызываться, как если бы она была методом этого второго аргумента.
// То есть второй аргумент будет доступен функции, как значение ключевого слова this. Значение, возвращаемое функцией, играет важную роль,
// но разные методы обрабатывают его по-разному. Ни один из методов массивов, введенных стандартом ECMAScript 5, не изменяет исходный массив.
// Разумеется, функция, передаваемая этим методам, может модифицировать исходный массив.

// 8.2.1 Метод forEach()
// Метод forEach() выполняет обход элементов массива и для каждого из них вызывает указанную функцию. Как уже говорилось выше,
// функция передается методу forEach() в первом аргументе. При вызове этой функции метод forEach() будет передавать ей три аргумента:
// значение элемента массива, индекс элемента и сам массив. Если вас интересует только значение элемента, можно написать функцию с
// одним параметром – дополнительные аргументы будут игнорироваться:

// var data = [1,2,3,4,5]; // Массив, элементы которого будут суммироваться
// // Найти сумму элементов массива
// var sum = 0; // Начальное значение суммы 0
// data.forEach(function(value) { sum += value; }); // Прибавить значение к sum
// sum // => 15
// // Увеличить все элементы массива на 1
// data.forEach(function(v, i, a) { a[i] = v + 1; });

// 8.2.2 Метод map()
// Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

// var numbers = [1, 4, 9];
// var roots = numbers.map(Math.sqrt);
// теперь roots равен [1, 2, 3], а numbers всё ещё равен [1, 4, 9]

// Функция map просто преобразует один массив в другой массив.

// var friends = [
//     {id:1, name: 'Dave',age:50},
//     {id:2,name: 'Kellie',age:42},
//     {id:3,name: 'Max',age:12},
//     {id:2,name: 'Jack',age:12}
// ];
// var friendsNamesList = friends.map(function(element) {
//     return element.name;
// });
//
// ["Dave", "Kellie", "Max", "Jack"]  // ["Dave", "Kellie", "Max", "Jack"]

























































