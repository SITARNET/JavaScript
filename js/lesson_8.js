// Arrays — Part 1st (Arrays and array processing)

// 1. Вступление
// Массив – это упорядоченная коллекция значений. Значения в массиве называются элементами, и каждый элемент характеризуется числовой позицией
// (или строкой если речь идет о ассоциативных массивах) в массиве, которая называется индексом (ключ для ассоциативных).
// Массивы в языке JavaScript являются нетипизированными: элементы массива могут иметь любой тип, причем разные элементы одного и того
// же массива могут иметь разные типы. Элементы массива могут даже быть объектами или другими массивами, что позволяет создавать сложные
// структуры данных, такие как массивы объектов и массивы массивов.
// В JavaScript есть 2 типа массивов: ассоциативные массивы и массивы с числовыми индексами.
// Ассоциативные массивы в JavaScript это не отдельный тип коллекции, а всего лишь объекты без методов.
// То есть если объект хранит данные и не делает с ними никаких действий это ассоциативный массив.
// В отличии от ассоциативных массивов, массивы с числовыми индексами в JavaScript считаются отдельной кастой (говорят подкласом) обычных объектов.
// Но не образуют отдельного типа данных как в других языках програмирования.

// 2. Объекты как ассоциативные массивы
// В этой главе мы рассмотрим использование объектов именно как массивов.
// Ассоциативные массивы - структура данных, в которой можно хранить любые данные в формате ключ-значение.
// Именно синтаксис доступа к полям объекта через квадратные скобки делает их похожими на ассоциативные массивы других языков програмирования.
// Так как ассоциативные массивы это просто объекты, все методики работы с объектами справедливы и к ассоциативным массивам.
// Могут закрасться сомнения нужно ли вводить такой термин как ассоциативные массивы, для JS колекций если это всего лишь объекты,
// но стоит знать что ассоциативные массивы имеют некие механизмы оптимизации, что приводит к отличиям реализаций таких структур на уровне памяти.
// А именно ассоциативные массивы поддерживают механизм компактного представления в памяти.

// 3. Массивы с числовыми индексами
// В этой главе мы рассмотрим использование подкласса Array - что реализовывает массивы с числовыми индексами в JavaScript.
// С этого момента и в будущем массивы с числовыми индексами мы будем называть просто массивами.
// Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для
// удобного манипулирования такой коллекцией.
// Отсчет индексов массивов в языке JavaScript начинается с нуля и для них используются 32-битные целые числа: первый элемент
// массива имеет индекс 0, а наибольший возможный индекс имеет значение 4294967295 элементов.

// 4. Создание массивов
// Легче всего создать массив с помощью литерала, который представляет собой простой список разделенных запятыми элементов массива в квадратных скобках.

// 'use strict';
// var empty = []; // Пустой массив
// var primes = [2, 3, 5, 7, 11]; // Массив с пятью числовыми элементами
// var misc = [ 1.1, true, "a" ]; // 3 элемента разных типов

// Значения в литерале массива не обязательно должны быть константами – это могут быть любые выражения:

// var base = 1024;
// var table = [base, base+1, base+2, base+3];

// Литералы массивов могут содержать литералы объектов или литералы других массивов:

// var b = [[1,{x:1, y:2}], [2, {x:3, y:4}]];

// Другой способ создания массива состоит в вызове конструктора Array(). Вызвать конструктор можно тремя разными способами:

// Вызвать конструктор без аргументов:
// var a = new Array();

// В этом случае будет создан пустой массив, эквивалентный литералу [].

// Вызвать конструктор с единственным числовым аргументом,
// определяющим длину массива:
// var a = new Array(10);

// В этом случае будет создан пустой массив указанной длины. Такая форма вызова конструктора Array() может использоваться для
// предварительного распределения памяти под массив, если заранее известно количество его элементов. Обратите внимание,
// что при этом в массиве не сохраняется никаких значений и даже свойства-индексы массива с именами «0», «1» и т.д. в массиве не определены.

// Явно указать в вызове конструктора значения первых двух или более
// элементов массива или один нечисловой элемент:
// var a = new Array(5, 4, 3, 2, 1, "testing, testing");

// В этом случае аргументы конструктора становятся значениями элементов нового массива. Использование литералов массивов практически всегда проще,
// чем подобное применение конструктора Array().

// 5. Доступ к элементам массива
// Доступ к элементам массива осуществляется с помощью оператора [ ]. Слева от скобок должна присутствовать ссылка на массив.
// Внутри скобок должно находиться произвольное выражение, возвращающее неотрицательное целое значение. Этот синтаксис пригоден как для чтения,
// так и для записи значения элемента массива. Следовательно, допустимы все приведенные далее JavaScript-инструкции:

// var a = ["world"]; // Создать массив с одним элементом
// var value = a[0]; // Прочитать элемент 0
// a[1] = 3.14; // Записать значение в элемент 1
// var i = 2;
// a[i] = 3; // Записать значение в элемент 2
// a[i + 1] = "hello"; // Записать значение в элемент 3
// a[a[i]] = a[0]; // Прочитать элементы 0 и 2, записать значение в элемент 3

// Напомню, что массивы являются специализированной разновидностью объектов. Квадратные скобки, используемые для доступа к элементам массива,
// действуют точно так же, как квадратные скобки, используемые для доступа к свойствам объекта. Интерпретатор JavaScript преобразует указанные
// в скобках числовые индексы в строки – индекс 1 превращается в строку "1", – а затем использует строки как имена свойств. В преобразовании
// числовых индексов в строки нет ничего особенного: то же самое можно проделывать с обычными объектами.

// 8.2 ES5
// Стандарт ECMAScript 5 определяет девять новых методов массивов, позволяющих выполнять итерации, отображение, фильтрацию, проверку, свертку и поиск.
// Все эти методы описываются в следующих далее подразделах.
// Однако, прежде чем перейти к изучению особенностей, следует сделать некоторые обобщения, касающиеся методов массивов в ECMAScript 5.
// Во-первых, большинство описываемых ниже методов принимают функцию в первом аргументе и вызывают ее для каждого элемента
// (или нескольких элементов) массива. В случае разреженных массивов указанная функция не будет вызываться для несуществующих элементов.
// В большинстве случаев указанной функции передаются три аргумента: значение элемента массива, индекс элемента и сам массив.
// Чаще всего вам необходим будет только первый аргумент, а второй и третий аргументы можно просто игнорировать.
// Большинство методов массивов, введенных стандартом ECMAScript 5, которые в первом аргументе принимают функцию, также принимают
// второй необязательный аргумент. Если он указан, функция будет вызываться, как если бы она была методом этого второго аргумента.
// То есть второй аргумент будет доступен функции, как значение ключевого слова this. Значение, возвращаемое функцией, играет важную роль,
// но разные методы обрабатывают его по-разному. Ни один из методов массивов, введенных стандартом ECMAScript 5, не изменяет исходный массив.
// Разумеется, функция, передаваемая этим методам, может модифицировать исходный массив.

// 8.2.1 Метод forEach()
// Метод forEach() выполняет обход элементов массива и для каждого из них вызывает указанную функцию. Как уже говорилось выше,
// функция передается методу forEach() в первом аргументе. При вызове этой функции метод forEach() будет передавать ей три аргумента:
// значение элемента массива, индекс элемента и сам массив. Если вас интересует только значение элемента, можно написать функцию с
// одним параметром – дополнительные аргументы будут игнорироваться:

// var data = [1,2,3,4,5]; // Массив, элементы которого будут суммироваться
// // Найти сумму элементов массива
// var sum = 0; // Начальное значение суммы 0
// data.forEach(function(value) { sum += value; }); // Прибавить значение к sum
// sum // => 15
// // Увеличить все элементы массива на 1
// data.forEach(function(v, i, a) { a[i] = v + 1; });

// 8.2.2 Метод map()
// Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

// var numbers = [1, 4, 9];
// var roots = numbers.map(Math.sqrt);
// теперь roots равен [1, 2, 3], а numbers всё ещё равен [1, 4, 9]

// Функция map просто преобразует один массив в другой массив.

// var friends = [
//     {id:1, name: 'Dave',age:50},
//     {id:2,name: 'Kellie',age:42},
//     {id:3,name: 'Max',age:12},
//     {id:2,name: 'Jack',age:12}
// ];
// var friendsNamesList = friends.map(function(element) {
//     return element.name;
// });
//
// ["Dave", "Kellie", "Max", "Jack"]  // ["Dave", "Kellie", "Max", "Jack"]

// 8.2.3 Метод filter()
// Метод filter() возвращает массив, содержащий подмножество элементов исходного массива. Передаваемая ему функция должна быть
// функцией-предикатом, т. е. должна возвращать значение true или false. Метод filter() вызывает функцию точно так же,
// как методы forEach() и map(). Если возвращается true или значение, которое может быть преобразовано в true, переданный функции
// элемент считается членом подмножества и добавляется в массив, возвращаемый методом. Например:

// a = [5, 4, 3, 2, 1];
// smallvalues = a.filter(function(x) { return x < 3 }); // [2, 1]
// everyother = a.filter(function(x,i) { return i%2==0 }); // [5, 3, 1]

// Обратите внимание, что метод filter() пропускает отсутствующие элементы в разреженных массивах и всегда возвращает плотные массивы.
// Чтобы уплотнить разреженный массив, можно выполнить следующие действия:

// var dense = sparse.filter(function() { return true; });
// А чтобы уплотнить массив и удалить из него все элементы со значениями undefined и null, можно использовать метод filter(), как показано ниже:

// a = a.filter(function(x) { return x !== undefined && x != null; });

// 8.2.3 Методы every() и some()
// Метод some() проверяет, удовлетворяет ли хоть какой-нибудь элемент массива условию, заданному в передаваемой функции.

// Метод some() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве до тех пор,
// пока не найдет такой, для которого callback вернет истинное значение (значение, становящееся равным true при приведении его
// к типу Boolean). Если такой элемент найден, метод some() немедленно вернёт true. В противном случае, если callback вернёт false для всех
// элементов массива, метод some() вернёт false. Функция callback вызывается только для индексов массива, имеющих присвоенные значения;
// она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались.

// function isBiggerThan10(element, index, array) {
//     return element > 10;
// }
// [2, 5, 8, 1, 4].some(isBiggerThan10);  // false
// [12, 5, 8, 1, 4].some(isBiggerThan10); // true

// Метод every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.

// Метод every() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве до тех пор,
// пока не найдет такой, для которого callback вернет ложное значение (значение, становящееся равным false при приведении его к типу Boolean).
// Если такой элемент найден, метод every() немедленно вернёт false. В противном случае, если callback вернёт true для всех элементов массива,
// метод every() вернёт true. Функция callback вызывается только для индексов массива, имеющих присвоенные значения;
// она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались.

// function isBigEnough(element, index, array) {
//     return element >= 10;
// }
// [12, 5, 8, 130, 44].every(isBigEnough);   // false
// [12, 54, 18, 130, 44].every(isBigEnough); // true

// 8.2.4 Методы reduce() и reduceRight()

// Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.
// Это один из самых сложных методов для работы с массивами. Но его стоит освоить, потому что временами с его помощью можно в несколько строк решить задачу,
// которая иначе потребовала бы в разы больше места и времени.
// Метод reduce используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива».
// Чуть далее мы разберём пример для вычисления суммы.
// Он применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.
// Аргументы функции callback(previousValue, currentItem, index, arr):

// previousValue – последний результат вызова функции, он же «промежуточный результат».
// currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
// index – номер текущего элемента.
// arr – обрабатываемый массив.
// Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение
// previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.

// Проще всего понять работу метода reduce на примере.
// Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.
// Вот решение в одну строку:

// var arr = [1, 2, 3, 4, 5]
//
// // для каждого элемента массива запустить функцию,
// // промежуточный результат передавать первым аргументом далее
// var result = arr.reduce(function(sum, current) {
//     return sum + current;
// }, 0);
// console.log( result ); // 15

// При первом запуске sum – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент reduce).
// Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и
// передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.

// Как видно, результат предыдущего вызова передаётся в первый аргумент следующего.
// Кстати, полный набор аргументов функции для reduce включает в себя function(sum, current, i, array), то есть номер текущего вызова i и весь массив arr,
// но здесь в них нет нужды.
// Посмотрим, что будет, если не указать initialValue в вызове arr.reduce:

// var arr = [1, 2, 3, 4, 5]
//
// // убрали 0 в конце
// var result = arr.reduce(function(sum, current) {
//     return sum + current
// });
//
// alert( result ); // 15

// Результат – точно такой же! Это потому, что при отсутствии initialValue в качестве первого значения берётся первый элемент массива,
// а перебор стартует со второго.
// Таблица вычислений будет такая же, за вычетом первой строки.
// Метод arr.reduceRight работает аналогично, но идёт по массиву справа-налево.






























































