// https://learn.javascript.ru/bubbling-and-capturing

// Всплытие и погружение
// Давайте начнём с примера.

// Этот обработчик для <div> сработает, если вы кликните по любому из вложенных тегов, будь то <em> или <code>:

// <div onclick="alert('Обработчик!')">
//     <em>Если вы кликните на <code>EM</code>, сработает обработчик на <code>DIV</code></em>
// </div>

// Вам не кажется это странным? Почему же сработал обработчик на <div>, если клик произошёл на <em>?

// Всплытие
// Принцип всплытия очень простой.

// Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.
// Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:

// <style>
//     body * {
//     margin: 10px;
//     border: 1px solid blue;
// }
// </style>
//
// <form onClick="alert('form')">FORM
//     <div onClick="alert('div')">DIV
//         <p onClick="alert('p')">P</p>
//     </div>
// </form>

// Клик по внутреннему <p> вызовет обработчик onclick:

// Сначала на самом <p>.
// Потом на внешнем <div>.
// Затем на внешнем <form>.
// И так далее вверх по цепочке до самого document.

// Поэтому если кликнуть на <p>, то мы увидим три оповещения: p → div → form.

// Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.

// Почти все события всплывают.
// Ключевое слово в этой фразе – «почти».

// Например, событие focus не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.

// event.target
// Всегда можно узнать, на каком конкретно элементе произошло событие.

// Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.

// Отличия от this (=event.currentTarget):

// event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
// this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.
// Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.

// При этом внутри обработчика form.onclick:

// this (=event.currentTarget) всегда будет элемент <form>, так как обработчик сработал на ней.
// event.target будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик.

// form.onclick = function(event) {
//     event.target.style.backgroundColor = 'yellow';
//
//     // браузеру нужно некоторое время, чтобы зарисовать всё жёлтым
//     setTimeout(() => {
//         alert("target = " + event.target.tagName + ", this=" + this.tagName);
//         event.target.style.backgroundColor = '';
//     }, 0);
// };

// Возможна и ситуация, когда event.target и this – один и тот же элемент, например, если клик был непосредственно на самом элементе <form>, а не на его подэлементе.

// Прекращение всплытия
// Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document,
// а иногда даже до window, вызывая все обработчики на своём пути.

// Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

// Для этого нужно вызвать метод event.stopPropagation().

// Например, здесь при клике на кнопку <button> обработчик body.onclick не сработает:

// <body onClick="alert(`сюда всплытие не дойдёт`)">
// <button onClick="event.stopPropagation()">Кликни меня</button>
// </body>

// event.stopImmediatePropagation()
// Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.

// То есть, event.stopPropagation() препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.

// Для того, чтобы полностью остановить обработку, существует метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

// Не прекращайте всплытие без необходимости!
// Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.

// Зачастую прекращение всплытия через event.stopPropagation() имеет свои подводные камни, которые со временем могут стать проблемами.

// Например:

// Мы делаем вложенное меню. Каждое подменю обрабатывает клики на своих элементах и делает для них stopPropagation, чтобы не срабатывало внешнее меню.
// Позже мы решили отслеживать все клики в окне для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди.
// Некоторые системы аналитики так делают. Обычно используют document.addEventListener('click'…), чтобы отлавливать все клики.
// Наша аналитика не будет работать над областью, где клики прекращаются stopPropagation. Увы, получилась «мёртвая зона».
// Зачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе.
// Например, с помощью создания своего уникального события, о том, как это делать, мы поговорим позже. Также мы можем записывать какую-то служебную
// информацию в объект event в одном обработчике, а читать в другом, таким образом мы можем сообщить обработчикам на родительских элементах информацию о том,
// что событие уже было как-то обработано.

// Погружение
// Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.

// Стандарт DOM Events описывает 3 фазы прохода события:

// 1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
// 2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
// 3. Фаза всплытия (bubbling stage) – событие начинает всплывать.

// Картинка из спецификации демонстрирует, как это работает при клике по ячейке <td>, расположенной внутри таблицы:

// То есть при клике на <td> событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели),
// а потом идёт наверх (всплытие), вызывая по пути обработчики.

// Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.

// Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через addEventListener(event, handler) с двумя аргументами,
// ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.

// Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:

// elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
// elem.addEventListener(..., true)

// Существуют два варианта значений опции capture:

// Если аргумент false (по умолчанию), то событие будет поймано при всплытии.
// Если аргумент true, то событие будет перехвачено при погружении.
// Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу («фазу цели»: событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение.

// Давайте посмотрим и всплытие и погружение в действии:

// <style>
//     body * {
//     margin: 10px;
//     border: 1px solid blue;
// }
// </style>

// <form>FORM
//     <div>DIV
//         <p>P</p>
//     </div>
// </form>

// <script>
//     for(let elem of document.querySelectorAll('*')) {
//     elem.addEventListener("click", e => alert(`Погружение: ${elem.tagName}`), true);
//     elem.addEventListener("click", e => alert(`Всплытие: ${elem.tagName}`));
// }
// </script>

// Здесь обработчики навешиваются на каждый элемент в документе, чтобы увидеть в каком порядке они вызываются по мере прохода события.

// Если вы кликните по <p>, то последовательность следующая:

// HTML → BODY → FORM → DIV (фаза погружения, первый обработчик)
// P (фаза цели, срабатывают обработчики, установленные и на погружение и на всплытие, так что выведется два раза)
// DIV → FORM → BODY → HTML (фаза всплытия, второй обработчик)
// Существует свойство event.eventPhase, содержащее номер фазы, на которой событие было поймано. Но оно используется редко, мы обычно и так знаем об этом в обработчике.

// Чтобы убрать обработчик removeEventListener, нужна та же фаза
// Если мы добавили обработчик вот так addEventListener(..., true), то мы должны передать то же значение аргумента capture в removeEventListener(..., true), когда снимаем обработчик.

// На каждой фазе разные обработчики на одном элементе срабатывают в порядке назначения
// Если у нас несколько обработчиков одного события, назначенных addEventListener на один элемент, в рамках одной фазы, то их порядок срабатывания – тот же, в котором они установлены:

// elem.addEventListener("click", e => alert(1)); // всегда сработает перед следующим
// elem.addEventListener("click", e => alert(2));

// Итого
// При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).

// Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
// Далее обработчики вызываются на целевом элементе.
// Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и addEventListener без третьего аргумента
// или с третьим аргументом равным false.
// Каждый обработчик имеет доступ к свойствам события event:

// event.target – самый глубокий элемент, на котором произошло событие.
// event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
// event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).
// Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

// В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.

// В реальном мире, когда происходит чрезвычайная ситуация, местные службы реагируют первыми. Они знают лучше всех местность, в которой это произошло, и другие детали.
// Вышестоящие инстанции подключаются уже после этого и при необходимости.

// Тоже самое справедливо для обработчиков событий. Код, который «навесил» обработчик на конкретный элемент, знает максимум деталей об элементе и его предназначении.
// Например, обработчик на определённом <td> скорее всего подходит только для этого конкретного <td>, он знает все о нём, поэтому он должен отработать первым.
// Далее имеет смысл передать обработку события родителю – он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта document,
// обработчик на котором реализовывает самую общую функциональность уровня документа.

// Всплытие и погружение являются основой для «делегирования событий» – очень мощного приёма обработки событий. Его мы изучим в следующей главе.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// Делегирование событий
// Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки – делегирование.

// Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому,
// мы ставим один обработчик на их общего предка.

// Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.

// Рассмотрим пример – диаграмму Ба-Гуа. Это таблица, отражающая древнюю китайскую философию.

// let table = document.getElementById('bagua-table');
//
// let selectedTd;
//
// table.onclick = function(event) {
//     let target = event.target; // где был клик?
//
//     while (target != this) { // не на TD? тогда не интересует
//         if (target.tagName == 'TD') {
//             highlight(target); // подсветить TD
//             return;
//         }
//         target = target.parentNode;
//     }
// }
//
// function highlight(node) {
//     if (selectedTd) {
//         selectedTd.classList.remove('highlight'); // убрать существующую подсветку, если есть
//     }
//     selectedTd = node;
//     selectedTd.classList.add('highlight'); // подсветить новый td
// }

// В этой таблице всего 9 ячеек, но могло бы быть и 99, и даже 9999, не важно.
// Наша задача – реализовать подсветку ячейки <td> при клике.
// Вместо того, чтобы назначать обработчик onclick для каждой ячейки <td> (их может быть очень много) – мы повесим «единый» обработчик на элемент <table>.
// Он будет использовать event.target, чтобы получить элемент, на котором произошло событие, и подсветить его.

// Такому коду нет разницы, сколько ячеек в таблице. Мы можем добавлять, удалять <td> из таблицы динамически в любое время, и подсветка будет стабильно работать.
// Однако, у текущей версии кода есть недостаток.
// Клик может быть не на теге <td>, а внутри него.
// В нашем случае, если взглянуть на HTML-код таблицы внимательно, видно, что ячейка <td> содержит вложенные теги, например <strong>:

// <td>
//     <strong>Северо-Запад</strong>
//     ...
// </td>

// Естественно, если клик произойдёт на элементе <strong>, то он станет значением event.target.

// Внутри обработчика table.onclick мы должны по event.target разобраться, был клик внутри <td> или нет.

// Вот улучшенный код:

// table.onclick = function(event) {
//     let td = event.target.closest('td'); // (1)
//
//     if (!td) return; // (2)
//
//     if (!table.contains(td)) return; // (3)
//
//     highlight(td); // (4)
// };

// Разберём пример:

// Метод elem.closest(selector) возвращает ближайшего предка, соответствующего селектору. В данном случае нам нужен <td>, находящийся выше по дереву от исходного элемента.
// Если event.target не содержится внутри элемента <td>, то вызов вернёт null, и ничего не произойдёт.
// Если таблицы вложенные, event.target может содержать элемент <td>, находящийся вне текущей таблицы. В таких случаях мы должны проверить, действительно ли это <td> нашей таблицы.
// И если это так, то подсвечиваем его.
// В итоге мы получили короткий код подсветки, быстрый и эффективный, которому совершенно не важно, сколько всего в таблице <td>.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Применение делегирования: действия в разметке
// Есть и другие применения делегирования.

// Например, нам нужно сделать меню с разными кнопками: «Сохранить (save)», «Загрузить (load)», «Поиск (search)» и т.д. И есть объект с соответствующими методами save, load, search…
// Как их состыковать?

// Первое, что может прийти в голову – это найти каждую кнопку и назначить ей свой обработчик среди методов объекта. Но существует более элегантное решение.
// Мы можем добавить один обработчик для всего меню и атрибуты data-action для каждой кнопки в соответствии с методами, которые они вызывают:

// <button data-action="save">Нажмите, чтобы Сохранить</button>
// Обработчик считывает содержимое атрибута и выполняет метод. Взгляните на рабочий пример:

// class Menu {
//     constructor(elem) {
//         this._elem = elem;
//         elem.onclick = this.onClick.bind(this); // (*)
//     }
//
//     save() {
//         alert('сохраняю');
//     }
//
//     load() {
//         alert('загружаю');
//     }
//
//     search() {
//         alert('ищу');
//     }
//
//     onClick(event) {
//         let action = event.target.dataset.action;
//         if (action) {
//             this[action]();
//         }
//     };
// }
//
// new Menu(menu);

// Обратите внимание, что метод this.onClick в строке, отмеченной звёздочкой (*), привязывается к контексту текущего объекта this. Это важно, т.к.
// иначе this внутри него будет ссылаться на DOM-элемент (elem), а не на объект Menu, и this[action] будет не тем, что нам нужно.

// Так что же даёт нам здесь делегирование?

// Не нужно писать код, чтобы присвоить обработчик каждой кнопке. Достаточно просто создать один метод и поместить его в разметку.
// Структура HTML становится по-настоящему гибкой. Мы можем добавлять/удалять кнопки в любое время.
// Мы также можем использовать классы .action-save, .action-load, но подход с использованием атрибутов data-action является более семантичным.
// Их можно использовать и для стилизации в правилах CSS.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Приём проектирования «поведение»
// Делегирование событий можно использовать для добавления элементам «поведения» (behavior), декларативно задавая хитрые обработчики установкой специальных HTML-атрибутов и классов.

// Приём проектирования «поведение» состоит из двух частей:

// Элементу ставится пользовательский атрибут, описывающий его поведение.
// При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и, если элемент имеет нужный атрибут, производит соответствующее действие.

// Поведение: «Счётчик»
// Например, здесь HTML-атрибут data-counter добавляет кнопкам поведение: «увеличить значение при клике»:

// document.addEventListener('click', function(event) {
//
//     if (event.target.dataset.counter != undefined) { // если есть атрибут...
//         event.target.value++;
//     }
//
// });

// Если нажать на кнопку – значение увеличится. Конечно, нам важны не счётчики, а общий подход, который здесь продемонстрирован.

// Элементов с атрибутом data-counter может быть сколько угодно. Новые могут добавляться в HTML-код в любой момент.
// При помощи делегирования мы фактически добавили новый «псевдостандартный» атрибут в HTML, который добавляет элементу новую возможность («поведение»).

// Всегда используйте метод addEventListener для обработчиков на уровне документа
// Когда мы устанавливаем обработчик событий на объект document, мы всегда должны использовать метод addEventListener, а не document.on<событие>,
// т.к. в случае последнего могут возникать конфликты: новые обработчики будут перезаписывать уже существующие.

// Для реального проекта совершенно нормально иметь много обработчиков на элементе document, установленных из разных частей кода.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Поведение: «Переключатель» (Toggle)
// Ещё один пример поведения. Сделаем так, что при клике на элемент с атрибутом data-toggle-id будет скрываться/показываться элемент с заданным id:

document.addEventListener('click', function(event) {
    let id = event.target.dataset.toggleId;
    if (!id) return;

    let elem = document.getElementById(id);

    elem.hidden = !elem.hidden;
});

// Ещё раз подчеркнём, что мы сделали. Теперь для того, чтобы добавить скрытие-раскрытие любому элементу, даже не надо знать JavaScript, можно просто написать атрибут data-toggle-id.

// Это бывает очень удобно – не нужно писать JavaScript-код для каждого элемента, который должен так себя вести. Просто используем поведение. Обработчики на уровне документа сделают
// это возможным для элемента в любом месте страницы.

// Мы можем комбинировать несколько вариантов поведения на одном элементе.

// Шаблон «поведение» может служить альтернативой для фрагментов JS-кода в вёрстке.

// Итого
// Делегирование событий – это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM.

// Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.

// Алгоритм:

// Вешаем обработчик на контейнер.
// В обработчике проверяем исходный элемент event.target.
// Если событие произошло внутри нужного нам элемента, то обрабатываем его.
// Зачем использовать:

// Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
// Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
// Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.
// Конечно, у делегирования событий есть свои ограничения:

// Во-первых, событие должно всплывать. Некоторые события этого не делают. Также, низкоуровневые обработчики не должны вызывать event.stopPropagation().
// Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера,
// не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.











