// https://learn.javascript.ru/bubbling-and-capturing

// Всплытие и погружение
// Давайте начнём с примера.

// Этот обработчик для <div> сработает, если вы кликните по любому из вложенных тегов, будь то <em> или <code>:

// <div onclick="alert('Обработчик!')">
//     <em>Если вы кликните на <code>EM</code>, сработает обработчик на <code>DIV</code></em>
// </div>

// Вам не кажется это странным? Почему же сработал обработчик на <div>, если клик произошёл на <em>?

// Всплытие
// Принцип всплытия очень простой.

// Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.
// Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:

// <style>
//     body * {
//     margin: 10px;
//     border: 1px solid blue;
// }
// </style>
//
// <form onClick="alert('form')">FORM
//     <div onClick="alert('div')">DIV
//         <p onClick="alert('p')">P</p>
//     </div>
// </form>

// Клик по внутреннему <p> вызовет обработчик onclick:

// Сначала на самом <p>.
// Потом на внешнем <div>.
// Затем на внешнем <form>.
// И так далее вверх по цепочке до самого document.

// Поэтому если кликнуть на <p>, то мы увидим три оповещения: p → div → form.

// Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.

// Почти все события всплывают.
// Ключевое слово в этой фразе – «почти».

// Например, событие focus не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.

// event.target
// Всегда можно узнать, на каком конкретно элементе произошло событие.

// Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.

// Отличия от this (=event.currentTarget):

// event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
// this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.
// Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.

// При этом внутри обработчика form.onclick:

// this (=event.currentTarget) всегда будет элемент <form>, так как обработчик сработал на ней.
// event.target будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик.

// form.onclick = function(event) {
//     event.target.style.backgroundColor = 'yellow';
//
//     // браузеру нужно некоторое время, чтобы зарисовать всё жёлтым
//     setTimeout(() => {
//         alert("target = " + event.target.tagName + ", this=" + this.tagName);
//         event.target.style.backgroundColor = '';
//     }, 0);
// };

// Возможна и ситуация, когда event.target и this – один и тот же элемент, например, если клик был непосредственно на самом элементе <form>, а не на его подэлементе.

// Прекращение всплытия
// Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document,
// а иногда даже до window, вызывая все обработчики на своём пути.

// Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

// Для этого нужно вызвать метод event.stopPropagation().

// Например, здесь при клике на кнопку <button> обработчик body.onclick не сработает:

// <body onClick="alert(`сюда всплытие не дойдёт`)">
// <button onClick="event.stopPropagation()">Кликни меня</button>
// </body>

// event.stopImmediatePropagation()
// Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.

// То есть, event.stopPropagation() препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.

// Для того, чтобы полностью остановить обработку, существует метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

// Не прекращайте всплытие без необходимости!
// Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.

// Зачастую прекращение всплытия через event.stopPropagation() имеет свои подводные камни, которые со временем могут стать проблемами.

// Например:

// Мы делаем вложенное меню. Каждое подменю обрабатывает клики на своих элементах и делает для них stopPropagation, чтобы не срабатывало внешнее меню.
// Позже мы решили отслеживать все клики в окне для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди.
// Некоторые системы аналитики так делают. Обычно используют document.addEventListener('click'…), чтобы отлавливать все клики.
// Наша аналитика не будет работать над областью, где клики прекращаются stopPropagation. Увы, получилась «мёртвая зона».
// Зачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе.
// Например, с помощью создания своего уникального события, о том, как это делать, мы поговорим позже. Также мы можем записывать какую-то служебную
// информацию в объект event в одном обработчике, а читать в другом, таким образом мы можем сообщить обработчикам на родительских элементах информацию о том,
// что событие уже было как-то обработано.

// Погружение
// Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.

// Стандарт DOM Events описывает 3 фазы прохода события:

// 1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
// 2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
// 3. Фаза всплытия (bubbling stage) – событие начинает всплывать.

// Картинка из спецификации демонстрирует, как это работает при клике по ячейке <td>, расположенной внутри таблицы:

// То есть при клике на <td> событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели),
// а потом идёт наверх (всплытие), вызывая по пути обработчики.

// Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.

// Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через addEventListener(event, handler) с двумя аргументами,
// ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.

// Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:

// elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
// elem.addEventListener(..., true)

// Существуют два варианта значений опции capture:

// Если аргумент false (по умолчанию), то событие будет поймано при всплытии.
// Если аргумент true, то событие будет перехвачено при погружении.
// Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу («фазу цели»: событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение.

// Давайте посмотрим и всплытие и погружение в действии:

// <style>
//     body * {
//     margin: 10px;
//     border: 1px solid blue;
// }
// </style>

// <form>FORM
//     <div>DIV
//         <p>P</p>
//     </div>
// </form>

// <script>
//     for(let elem of document.querySelectorAll('*')) {
//     elem.addEventListener("click", e => alert(`Погружение: ${elem.tagName}`), true);
//     elem.addEventListener("click", e => alert(`Всплытие: ${elem.tagName}`));
// }
// </script>

// Здесь обработчики навешиваются на каждый элемент в документе, чтобы увидеть в каком порядке они вызываются по мере прохода события.

// Если вы кликните по <p>, то последовательность следующая:

// HTML → BODY → FORM → DIV (фаза погружения, первый обработчик)
// P (фаза цели, срабатывают обработчики, установленные и на погружение и на всплытие, так что выведется два раза)
// DIV → FORM → BODY → HTML (фаза всплытия, второй обработчик)
// Существует свойство event.eventPhase, содержащее номер фазы, на которой событие было поймано. Но оно используется редко, мы обычно и так знаем об этом в обработчике.

// Чтобы убрать обработчик removeEventListener, нужна та же фаза
// Если мы добавили обработчик вот так addEventListener(..., true), то мы должны передать то же значение аргумента capture в removeEventListener(..., true), когда снимаем обработчик.

// На каждой фазе разные обработчики на одном элементе срабатывают в порядке назначения
// Если у нас несколько обработчиков одного события, назначенных addEventListener на один элемент, в рамках одной фазы, то их порядок срабатывания – тот же, в котором они установлены:

// elem.addEventListener("click", e => alert(1)); // всегда сработает перед следующим
// elem.addEventListener("click", e => alert(2));

// Итого
// При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).

// Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
// Далее обработчики вызываются на целевом элементе.
// Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и addEventListener без третьего аргумента
// или с третьим аргументом равным false.
// Каждый обработчик имеет доступ к свойствам события event:

// event.target – самый глубокий элемент, на котором произошло событие.
// event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
// event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).
// Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

// В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.

// В реальном мире, когда происходит чрезвычайная ситуация, местные службы реагируют первыми. Они знают лучше всех местность, в которой это произошло, и другие детали.
// Вышестоящие инстанции подключаются уже после этого и при необходимости.

// Тоже самое справедливо для обработчиков событий. Код, который «навесил» обработчик на конкретный элемент, знает максимум деталей об элементе и его предназначении.
// Например, обработчик на определённом <td> скорее всего подходит только для этого конкретного <td>, он знает все о нём, поэтому он должен отработать первым.
// Далее имеет смысл передать обработку события родителю – он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта document,
// обработчик на котором реализовывает самую общую функциональность уровня документа.

// Всплытие и погружение являются основой для «делегирования событий» – очень мощного приёма обработки событий. Его мы изучим в следующей главе.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// Делегирование событий
// Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки – делегирование.

// Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому,
// мы ставим один обработчик на их общего предка.

// Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.

// Рассмотрим пример – диаграмму Ба-Гуа. Это таблица, отражающая древнюю китайскую философию.

// let table = document.getElementById('bagua-table');
//
// let selectedTd;
//
// table.onclick = function(event) {
//     let target = event.target; // где был клик?
//
//     while (target != this) { // не на TD? тогда не интересует
//         if (target.tagName == 'TD') {
//             highlight(target); // подсветить TD
//             return;
//         }
//         target = target.parentNode;
//     }
// }
//
// function highlight(node) {
//     if (selectedTd) {
//         selectedTd.classList.remove('highlight'); // убрать существующую подсветку, если есть
//     }
//     selectedTd = node;
//     selectedTd.classList.add('highlight'); // подсветить новый td
// }

// В этой таблице всего 9 ячеек, но могло бы быть и 99, и даже 9999, не важно.
// Наша задача – реализовать подсветку ячейки <td> при клике.
// Вместо того, чтобы назначать обработчик onclick для каждой ячейки <td> (их может быть очень много) – мы повесим «единый» обработчик на элемент <table>.
// Он будет использовать event.target, чтобы получить элемент, на котором произошло событие, и подсветить его.

// Такому коду нет разницы, сколько ячеек в таблице. Мы можем добавлять, удалять <td> из таблицы динамически в любое время, и подсветка будет стабильно работать.
// Однако, у текущей версии кода есть недостаток.
// Клик может быть не на теге <td>, а внутри него.
// В нашем случае, если взглянуть на HTML-код таблицы внимательно, видно, что ячейка <td> содержит вложенные теги, например <strong>:

// <td>
//     <strong>Северо-Запад</strong>
//     ...
// </td>

// Естественно, если клик произойдёт на элементе <strong>, то он станет значением event.target.

// Внутри обработчика table.onclick мы должны по event.target разобраться, был клик внутри <td> или нет.

// Вот улучшенный код:

// table.onclick = function(event) {
//     let td = event.target.closest('td'); // (1)
//
//     if (!td) return; // (2)
//
//     if (!table.contains(td)) return; // (3)
//
//     highlight(td); // (4)
// };

// Разберём пример:

// Метод elem.closest(selector) возвращает ближайшего предка, соответствующего селектору. В данном случае нам нужен <td>, находящийся выше по дереву от исходного элемента.
// Если event.target не содержится внутри элемента <td>, то вызов вернёт null, и ничего не произойдёт.
// Если таблицы вложенные, event.target может содержать элемент <td>, находящийся вне текущей таблицы. В таких случаях мы должны проверить, действительно ли это <td> нашей таблицы.
// И если это так, то подсвечиваем его.
// В итоге мы получили короткий код подсветки, быстрый и эффективный, которому совершенно не важно, сколько всего в таблице <td>.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Применение делегирования: действия в разметке
// Есть и другие применения делегирования.

// Например, нам нужно сделать меню с разными кнопками: «Сохранить (save)», «Загрузить (load)», «Поиск (search)» и т.д. И есть объект с соответствующими методами save, load, search…
// Как их состыковать?

// Первое, что может прийти в голову – это найти каждую кнопку и назначить ей свой обработчик среди методов объекта. Но существует более элегантное решение.
// Мы можем добавить один обработчик для всего меню и атрибуты data-action для каждой кнопки в соответствии с методами, которые они вызывают:

// <button data-action="save">Нажмите, чтобы Сохранить</button>
// Обработчик считывает содержимое атрибута и выполняет метод. Взгляните на рабочий пример:

// class Menu {
//     constructor(elem) {
//         this._elem = elem;
//         elem.onclick = this.onClick.bind(this); // (*)
//     }
//
//     save() {
//         alert('сохраняю');
//     }
//
//     load() {
//         alert('загружаю');
//     }
//
//     search() {
//         alert('ищу');
//     }
//
//     onClick(event) {
//         let action = event.target.dataset.action;
//         if (action) {
//             this[action]();
//         }
//     };
// }
//
// new Menu(menu);

// Обратите внимание, что метод this.onClick в строке, отмеченной звёздочкой (*), привязывается к контексту текущего объекта this. Это важно, т.к.
// иначе this внутри него будет ссылаться на DOM-элемент (elem), а не на объект Menu, и this[action] будет не тем, что нам нужно.

// Так что же даёт нам здесь делегирование?

// Не нужно писать код, чтобы присвоить обработчик каждой кнопке. Достаточно просто создать один метод и поместить его в разметку.
// Структура HTML становится по-настоящему гибкой. Мы можем добавлять/удалять кнопки в любое время.
// Мы также можем использовать классы .action-save, .action-load, но подход с использованием атрибутов data-action является более семантичным.
// Их можно использовать и для стилизации в правилах CSS.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Приём проектирования «поведение»
// Делегирование событий можно использовать для добавления элементам «поведения» (behavior), декларативно задавая хитрые обработчики установкой специальных HTML-атрибутов и классов.

// Приём проектирования «поведение» состоит из двух частей:

// Элементу ставится пользовательский атрибут, описывающий его поведение.
// При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и, если элемент имеет нужный атрибут, производит соответствующее действие.

// Поведение: «Счётчик»
// Например, здесь HTML-атрибут data-counter добавляет кнопкам поведение: «увеличить значение при клике»:

// document.addEventListener('click', function(event) {
//
//     if (event.target.dataset.counter != undefined) { // если есть атрибут...
//         event.target.value++;
//     }
//
// });

// Если нажать на кнопку – значение увеличится. Конечно, нам важны не счётчики, а общий подход, который здесь продемонстрирован.

// Элементов с атрибутом data-counter может быть сколько угодно. Новые могут добавляться в HTML-код в любой момент.
// При помощи делегирования мы фактически добавили новый «псевдостандартный» атрибут в HTML, который добавляет элементу новую возможность («поведение»).

// Всегда используйте метод addEventListener для обработчиков на уровне документа
// Когда мы устанавливаем обработчик событий на объект document, мы всегда должны использовать метод addEventListener, а не document.on<событие>,
// т.к. в случае последнего могут возникать конфликты: новые обработчики будут перезаписывать уже существующие.

// Для реального проекта совершенно нормально иметь много обработчиков на элементе document, установленных из разных частей кода.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Поведение: «Переключатель» (Toggle)
// Ещё один пример поведения. Сделаем так, что при клике на элемент с атрибутом data-toggle-id будет скрываться/показываться элемент с заданным id:

// document.addEventListener('click', function(event) {
//     let id = event.target.dataset.toggleId;
//     if (!id) return;
//
//     let elem = document.getElementById(id);
//
//     elem.hidden = !elem.hidden;
// });

// Ещё раз подчеркнём, что мы сделали. Теперь для того, чтобы добавить скрытие-раскрытие любому элементу, даже не надо знать JavaScript, можно просто написать атрибут data-toggle-id.

// Это бывает очень удобно – не нужно писать JavaScript-код для каждого элемента, который должен так себя вести. Просто используем поведение. Обработчики на уровне документа сделают
// это возможным для элемента в любом месте страницы.

// Мы можем комбинировать несколько вариантов поведения на одном элементе.

// Шаблон «поведение» может служить альтернативой для фрагментов JS-кода в вёрстке.

// Итого
// Делегирование событий – это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM.

// Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.

// Алгоритм:

// Вешаем обработчик на контейнер.
// В обработчике проверяем исходный элемент event.target.
// Если событие произошло внутри нужного нам элемента, то обрабатываем его.
// Зачем использовать:

// Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
// Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
// Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.
// Конечно, у делегирования событий есть свои ограничения:

// Во-первых, событие должно всплывать. Некоторые события этого не делают. Также, низкоуровневые обработчики не должны вызывать event.stopPropagation().
// Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера,
// не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.

// Task 1
// Спрячьте сообщения с помощью делегирования
// Дан список сообщений с кнопками для удаления [x]. Заставьте кнопки работать.

// P.S. Используйте делегирование событий. Должен быть лишь один обработчик на элементе-контейнере для всего.


// container.onclick = function(event) { // вешаем на id="container" событие .onclick
//     if (event.target.className != 'remove-button') return; // если элемент (цель) не имеет нужный атрибут 'remove-button', возвращаем
//
//     let pane = event.target.closest('.pane'); // ищем ближайший родительский элемент класса 'pane'
//     pane.remove(); // удаляем класс 'pane'
// };

// Task 2
// Раскрывающееся дерево

// Создайте дерево, которое по клику на заголовок скрывает-показывает потомков:

// поместить все текстовые узлы в элемент <span>
// он занимает только то место, которое необходимо для текста

// for (let li of tree.querySelectorAll('li')) {
//     let span = document.createElement('span'); // создаём елемент span в li
//     li.prepend(span); // вставляем в начало
//     span.append(span.nextSibling); // поместить текстовый узел внутрь элемента <span>
// }
//
// //  ловим клики на всём дереве
// tree.onclick = function(event) {
//
//     if (event.target.tagName != 'SPAN') {
//         return;
//     }
//
//     let childrenContainer = event.target.parentNode.querySelector('ul');
//     if (!childrenContainer) return; // нет детей
//
//     childrenContainer.hidden = !childrenContainer.hidden;
// }

// Task 3

// Сортируемая таблица

// Сделать таблицу сортируемой: при клике на элемент <th> строки таблицы должны сортироваться по соответствующему столбцу.
// Таблица может быть большой, с любым числом строк и столбцов.
// Каждый элемент <th> имеет атрибут data-type:


// grid.onclick = function(e) {
//     if (e.target.tagName != 'TH') return;
//
//     let th = e.target; // цель
//     // если ячейка TH, тогда сортировать
//     // cellIndex - это номер ячейки th:
//     //   0 для первого столбца
//     //   1 для второго и т.д.
//     sortGrid(th.cellIndex, th.dataset.type); // номер ячейки в строке, data-type = number или string
// };
//
// function sortGrid(colNum, type) {
//     let tbody = grid.querySelector('tbody'); // озвращает первый элемент (Element) документа,
//     // который соответствует указанному селектору или группе селекторов.
//
//     let rowsArray = Array.from(tbody.rows); // создаём массив из коллекции строк tr в tbody
//
//     // compare(a, b) сравнивает две строки, нужен для сортировки
//     let compare;
//
//     switch (type) {
//         case 'number': // если число
//             compare = function(rowA, rowB) {
//                 return rowA.cells[colNum].innerHTML - rowB.cells[colNum].innerHTML; // возвращаем разницу
//                 // значения (HTML разметка дочерного элемента) ячейки в переменной rowA и
//                 // значения (HTML разметка дочерного элемента) ячейки в переменной rowB
//             };
//             break;
//         case 'string': // если строка
//             compare = function(rowA, rowB) {
//                 return rowA.cells[colNum].innerHTML > rowB.cells[colNum].innerHTML ? 1 : -1; // если
//                 // значения (HTML разметка дочерного элемента) ячейки в переменной rowA больше
//                 // значения (HTML разметка дочерного элемента) ячейки в переменной rowB, то = 1, иначе = -1
//             };
//             break;
//     }
//
//     rowsArray.sort(compare); // на месте сортирует элементы массива и возвращает отсортированный массив.
//
//     tbody.append(...rowsArray); // добавлет в конец, расширяет массив где несколько аргументов (расскрывает массив)
// }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Task 4

// Поведение "подсказка"

// Напишите JS-код, реализующий поведение «подсказка».

// При наведении мыши на элемент с атрибутом data-tooltip, над ним должна показываться подсказка и скрываться
// при переходе на другой элемент.

// Пример HTML с подсказками:

// <button data-tooltip="эта подсказка длиннее, чем элемент">Короткая кнопка</button>
// <button data-tooltip="HTML<br>подсказка">Ещё кнопка</button>

// В этой задаче мы полагаем, что во всех элементах с атрибутом data-tooltip – только текст. То есть,
// в них нет вложенных тегов (пока).

// Детали оформления:

// Отступ от подсказки до элемента с data-tooltip должен быть 5px по высоте.
// Подсказка должна быть, по возможности, посередине элемента.
// Подсказка не должна вылезать за границы экрана, в том числе если страница частично прокручена, если нельзя
// показать сверху – показывать снизу элемента.
// Текст подсказки брать из значения атрибута data-tooltip. Это может быть произвольный HTML.
// Для решения вам понадобятся два события:

// mouseover срабатывает, когда указатель мыши заходит на элемент.
// mouseout срабатывает, когда указатель мыши уходит с элемента.
// Примените делегирование событий: установите оба обработчика на элемент document, чтобы отслеживать «заход»
// и «уход» курсора на элементы с атрибутом data-tooltip и управлять подсказками с их же помощью.

// После реализации поведения – люди, даже не знакомые с JavaScript смогут добавлять подсказки к элементам.

// P.S. В один момент может быть показана только одна подсказка.

// let tooltipElem;
//
// document.onmouseover = function(event) { // вешаем, когда наводишь мышку
//     let target = event.target; // цель
//
//     let tooltipHtml = target.dataset.tooltip;
//     if (!tooltipHtml) return; // если у нас есть подсказка
//
//     // ...создадим элемент для подсказки
//
//     tooltipElem = document.createElement('div'); // создаём элемент
//     tooltipElem.className = 'tooltip'; // создаём класс
//     tooltipElem.innerHTML = tooltipHtml; // вставляем текст подсказки
//     document.body.append(tooltipElem); // добовляем в конец <div class="tooltip">Текст подсказки</div>
//
//     // спозиционируем его сверху от аннотируемого элемента (top-center)
//     let coords = target.getBoundingClientRect(); // возвращает размер элемента и его позицию относительно viewport
//     // (часть страницы, показанная на экране, и которую мы видим).
//
//     let left = coords.left + (target.offsetWidth - tooltipElem.offsetWidth) / 2;
//
//     // .left - возвращает значение левой координаты DOMRect.
//     // .offsetWidth - возвращает ширину элемента. Как правило, offsetWidth — это значение, включающее горизонтальный отступ элемента,
//     // ширину вертикального скроллбара (если он есть) и CSS ширину.
//
//     if (left < 0) left = 0; // не заезжать за левый край окна
//
//     let top = coords.top - tooltipElem.offsetHeight - 5;
//
//     // .top - возвращает значение верхней координаты DOMRect.
//     // .offsetHeight - высота элемента с учетом вертикальных полей и границ в пикселях.
//     // Свойство неизменяемое, только для чтения.
//
//     if (top < 0) { // если подсказка не помещается сверху, то отображать её снизу
//         top = coords.top + target.offsetHeight + 5;
//     }
//
//     tooltipElem.style.left = left + 'px';
//     tooltipElem.style.top = top + 'px';
// };
//
// document.onmouseout = function(e) { // вешаем, когда отводишь мышку
//
//     if (tooltipElem) { // если true
//         tooltipElem.remove(); // удаляет указанные токены из списка.
//         tooltipElem = null; // присваеваем null
//     }
//
// };

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Действия браузера по умолчанию
// Многие события автоматически влекут за собой действие браузера.

// Например:

//     Клик по ссылке инициирует переход на новый URL.
//     Нажатие на кнопку «отправить» в форме – отсылку её на сервер.
//     Зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение.
//     Если мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно.
//     К счастью, его можно отменить.

// Отмена действия браузера
// Есть два способа отменить действие браузера:

// Основной способ – это воспользоваться объектом event. Для отмены действия браузера существует
// стандартный метод event.preventDefault().
// Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть
// false из обработчика.
// В следующем примере при клике по ссылке переход не произойдёт:

// <a href="/" onClick="return false">Нажми здесь</a>
// или
// < a href = "/" onClick = "event.preventDefault()" > здесь < /a>

// Возвращать true не нужно
// Обычно значение, которое возвращает обработчик события, игнорируется.

// Единственное исключение – это return false из обработчика, назначенного через on<событие>.

// В других случаях return не нужен, он никак не обрабатывается.

// <ul id="menu" className="menu">
//     <li><a href="/html">HTML</a></li>
//     <li><a href="/javascript">JavaScript</a></li>
//     <li><a href="/css">CSS</a></li>
// </ul>

// В HTML-разметке все элементы меню являются не кнопками, а ссылками, то есть тегами <a>. В этом подходе есть некоторые преимущества, например:

// Некоторые посетители очень любят сочетание «правый клик – открыть в новом окне». Если мы будем использовать <button> или <span>, то данное сочетание работать не будет.
// Поисковые движки переходят по ссылкам <a href="..."> при индексации.
// Поэтому в разметке мы используем <a>. Но нам необходимо обрабатывать клики в JavaScript, а стандартное действие браузера (переход по ссылке) – отменить.

// Например, вот так:

// menu.onclick = function(event) {
//     if (event.target.nodeName != 'A') return;
//
//     let href = event.target.getAttribute('href'); // возвращает значение указанного атрибута элемента.
//     // Если элемент не содержит данный атрибут, могут быть возвращены null или "" (пустая строка);
//     alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.
//
//     return false; // отменить действие браузера (переход по ссылке)
// };

// Если мы уберём return false, то после выполнения обработчика события браузер выполнит «действие по умолчанию» – переход по адресу из href.
// А это нам здесь не нужно, мы обрабатываем клик сами.

// Кстати, использование здесь делегирования событий делает наше меню очень гибким.
// Мы можем добавить вложенные списки и стилизовать их с помощью CSS – обработчик не потребует изменений.

// События, вытекающие из других
// Некоторые события естественным образом вытекают друг из друга. Если мы отменим первое событие, то последующие не возникнут.

// Например, событие mousedown для поля <input> приводит к фокусировке на нём и запускает событие focus.
// Если мы отменим событие mousedown, то фокусирования не произойдёт.

// В следующем примере попробуйте нажать на первом <input> – происходит событие focus. Но если вы нажимаете по второму элементу, то события focus не будет.

// <input value="Фокус работает" onFocus="this.value=''">
// <input onMouseDown="return false" onFocus="this.value=''" value="Кликни меня">

// Это потому, что отменено стандартное действие mousedown. Впрочем, фокусировка на элементе всё ещё возможна, если мы будем использовать другой способ.
// Например, нажатием клавиши Tab можно перейти от первого поля ввода ко второму. Но только не через клик мышью на элемент, это больше не работает.

// Опция «passive» для обработчика
// Необязательная опция passive: true для addEventListener сигнализирует браузеру, что обработчик не собирается выполнять preventDefault().

// Почему это может быть полезно?

// Есть некоторые события, как touchmove на мобильных устройствах (когда пользователь перемещает палец по экрану), которое по умолчанию начинает прокрутку,
// но мы можем отменить это действие, используя preventDefault() в обработчике.

// Поэтому, когда браузер обнаружит такое событие, он должен для начала запустить все обработчики и после, если preventDefault не вызывается нигде,
// он может начать прокрутку. Это может вызвать ненужные задержки в пользовательском интерфейсе.

// Опция passive: true сообщает браузеру, что обработчик не собирается отменять прокрутку. Тогда браузер начинает её немедленно,
// обеспечивая максимально плавный интерфейс, параллельно обрабатывая событие.

// Для некоторых браузеров (Firefox, Chrome) опция passive по умолчанию включена в true для таких событий, как touchstart и touchmove.

// event.defaultPrevented
// Свойство event.defaultPrevented установлено в true, если действие по умолчанию было предотвращено, и false, если нет.

// Рассмотрим практическое применение этого свойства для улучшения архитектуры.

// Помните, в главе Всплытие и погружение мы говорили о event.stopPropagation() и упоминали, что останавливать «всплытие» – плохо?

// Иногда вместо этого мы можем использовать event.defaultPrevented, чтобы просигналить другим обработчикам, что событие обработано.

// Давайте посмотрим практический пример.

// По умолчанию браузер при событии contextmenu (клик правой кнопкой мыши) показывает контекстное меню со стандартными опциями.
// Мы можем отменить событие по умолчанию и показать своё меню, как здесь:

// <button>Правый клик вызывает контекстное меню браузера</button>
//
// <button onContextMenu="alert('Рисуем наше меню'); return false">
//     Правый клик вызывает наше контекстное меню
// </button>

// Теперь в дополнение к этому контекстному меню реализуем контекстное меню для всего документа.

// При правом клике должно показываться ближайшее контекстное меню.

// <p>Правый клик здесь вызывает контекстное меню документа</p>
// <button id="elem">Правый клик здесь вызывает контекстное меню кнопки</button>
//
// <script>
//     elem.oncontextmenu = function(event) {
//     event.preventDefault();
//     alert("Контекстное меню кнопки");
// };
//
//     document.oncontextmenu = function(event) {
//     event.preventDefault();
//     alert("Контекстное меню документа");
// };
// </script>

// Проблема заключается в том, что когда мы кликаем по элементу elem, то мы получаем два меню: контекстное меню для кнопки
// и (событие всплывает вверх) контекстное меню для документа.

// Как это поправить? Одно из решений – это подумать: «Когда мы обрабатываем правый клик в обработчике на кнопке,
// остановим всплытие», и вызвать event.stopPropagation():

// <p>Правый клик вызывает меню документа</p>
// <button id="elem">Правый клик вызывает меню кнопки (добавлен event.stopPropagation)</button>
//
// <script>
//     elem.oncontextmenu = function(event) {
//     event.preventDefault();
//     event.stopPropagation();
//     alert("Контекстное меню кнопки");
// };
//
//     document.oncontextmenu = function(event) {
//     event.preventDefault();
//     alert("Контекстное меню документа");
// };
// </script>

// Теперь контекстное меню для кнопки работает как задумано. Но цена слишком высока. Мы навсегда запретили доступ к
// информации о правых кликах для любого внешнего кода, включая счётчики, которые могли бы собирать статистику, и т.п. Это слегка неразумно.

// Альтернативным решением было бы проверить в обработчике document, было ли отменено действие по умолчанию? Если да,
// тогда событие было обработано, и нам не нужно на него реагировать.

// elem.oncontextmenu = function (event) {
//     event.preventDefault();
//     alert("Контекстное меню кнопки");
// };
//
// document.oncontextmenu = function (event) {
//     if (event.defaultPrevented) return;
//
//     event.preventDefault();
//     alert("Контекстное меню документа");
// };

// Сейчас всё работает правильно. Если у нас есть вложенные элементы и каждый из них имеет контекстное меню, то код также будет работать.
// Просто убедитесь, что проверяете event.defaultPrevented в каждом обработчике contextmenu.

// event.stopPropagation() и event.preventDefault()
// Как мы можем видеть, event.stopPropagation() и event.preventDefault() (также известный как return false) – это две разные функции. Они никак не связаны друг с другом.

// Архитектура вложенных контекстных меню
// Есть также несколько альтернативных путей, чтобы реализовать вложенные контекстные меню. Одним из них является единый глобальный объект с обработчиком
// document.oncontextmenu и методами, позволяющими хранить в нём другие обработчики.

// Объект будет перехватывать любой клик правой кнопкой мыши, просматривать сохранённые обработчики и запускать соответствующий.

// Но при этом каждый фрагмент кода, которому требуется контекстное меню, должен знать об этом объекте и использовать его вместо собственного обработчика contextmenu.

// Итого
// Действий браузера по умолчанию достаточно много:

//     mousedown – начинает выделять текст (если двигать мышкой).
//     click на <input type="checkbox"> – ставит или убирает галочку в input.
//     submit – при нажатии на <input type="submit"> или при нажатии клавиши Enter в форме данные отправляются на сервер.
//     keydown – при нажатии клавиши в поле ввода появляется символ.
//     contextmenu – при правом клике показывается контекстное меню браузера.
//     …и многие другие…

// Все эти действия можно отменить, если мы хотим обработать событие исключительно при помощи JavaScript.
// Чтобы отменить действие браузера по умолчанию, используйте event.preventDefault() или return false. Второй метод работает, только если обработчик назначен через on<событие>.
// Опция passive: true для addEventListener сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных устройствах,
// таких как touchstart и touchmove, чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а ему следует сразу приступать к выполнению действия по
// умолчанию, например, к прокрутке.

// Если событие по умолчанию отменено, то значение event.defaultPrevented становится true, иначе false.

// Сохраняйте семантику, не злоупотребляйте
// Технически, отменяя действия браузера по умолчанию и добавляя JavaScript, мы можем настроить поведение любого элемента. Например, мы можем заставить ссылку <a> работать
// как кнопку, а кнопку <button> вести себя как ссылка (перенаправлять на другой URL).

// Но нам следует сохранять семантическое значение HTML элементов. Например, не кнопки, а тег <a> должен применяться для переходов по ссылкам.
// Помимо того, что это «хорошо», это делает ваш HTML лучше с точки зрения доступности для людей с ограниченными возможностями и с особых устройств.

// Также, если мы рассматриваем пример с тегом <a>, то обратите внимание: браузер предоставляет возможность открывать ссылки в новом окне
// (кликая правой кнопкой мыши или используя другие возможности). И пользователям это нравится. Но если мы заменим ссылку кнопкой и стилизуем её как ссылку,
// используя CSS, то специфичные функции браузера для тега <a> всё равно работать не будут.

// Task 5

// Почему не работает return false?

// Почему в коде ниже return false не работает?

// <script>
//     function handler() {
//     alert("...");
//     return false;
// }
// </script>
//
// <a href="http://w3.org" onclick="handler()">браузер откроет w3.org</a>

// Браузер переходит по указанной ссылке, но нам этого не нужно.
// Как поправить?

// Когда браузер считывает атрибут on*, например onclick, он создаёт функцию-обработчик с содержимым этого атрибута в качестве тела функции.

// Функция для onclick="handler()" будет:

// function (event) {
//     handler() // содержимое onclick
// }

// Сейчас нам видно, что возвращаемое значение handler() не используется и не влияет на результат.
// Исправить очень просто:

// <script>
//     function handler() {
//     alert("...");
//     return false;
// }
// </script>
//
// <a href="http://w3.org" onClick="return handler()">w3.org</a>

// Также мы можем использовать event.preventDefault(), например:

//     function handler(event) {
//     alert("...");
//     event.preventDefault(); // отмена действия браузера
// }

// Task 6

// Поймайте переход по ссылке

// Сделайте так, чтобы при клике на ссылки внутри элемента id="contents" пользователю выводился вопрос о том, действительно
// ли он хочет покинуть страницу, и если он не хочет, то прерывать переход по ссылке.

// Детали:

// Содержимое #contents может быть загружено динамически и присвоено при помощи innerHTML. Так что найти все ссылки и поставить
// на них обработчики нельзя. Используйте делегирование.
// Содержимое может иметь вложенные теги, в том числе внутри ссылок, например, <a href=".."><i>...</i></a>.

// Это – классическая задача на тему делегирования.

// В реальной жизни мы можем перехватить событие и создать AJAX-запрос к серверу, который сохранит информацию о том,
// по какой ссылке ушёл посетитель. Или мы можем загрузить содержимое и отобразить его прямо на странице (если допустимо).

// Всё, что нам необходимо, это поймать событие contents.onclick и использовать функцию confirm, чтобы задать вопрос пользователю.
// Хорошей идеей было бы использовать link.getAttribute('href') вместо link.href для ссылок. Смотрите решение в песочнице.

// contents.onclick = function(event) {
//
//     function handleLink(href) {
//         let isLeaving = confirm(`Leave for ${href}?`);
//         if (!isLeaving) return false;
//     }
//
//     let target = event.target.closest('a'); // возвращает ближайший родительский элемент (или сам элемент),
//     // который соответствует заданному CSS-селектору или null, если таковых элементов вообще нет.
//
//     if (target && contents.contains(target)) { // возвращает Boolean значение, указывающее, является ли узел потомком данного узла, т. е.
//         // сам узел, один из его прямых потомков ( childNodes ), один из детей его детей и так далее.
//         return handleLink(target.getAttribute('href')); // возвращает в функцию значение указанного атрибута элемента. Если элемент
//         // не содержит данный атрибут, могут быть возвращены null или "" (пустая строка);
//     }
// };

// Task 7

// Галерея изображений
// Создайте галерею изображений, в которой основное изображение изменяется при клике на уменьшенный вариант.

// P.S. Используйте делегирование.

// Решение состоит в том, чтобы добавить обработчик на контейнер #thumbs и отслеживать клики на ссылках.
// Если клик происходит по ссылке <a>, тогда меняем атрибут src элемента #largeImg на href уменьшенного изображения.

// thumbs.onclick = function(event) {
//     let thumbnail = event.target.closest('a'); // возвращает ближайший родительский элемент (или сам элемент)
//
//     if (!thumbnail) return;
//     showThumbnail(thumbnail.href, thumbnail.title);
//
//     // .href - это USVString, содержащий URL целиком.
//     // .title - свойство представляет заголовок элемента.
//
//     event.preventDefault(); // отмена действия браузера по умолчанию.
// }
//
// function showThumbnail(href, title) {
//     largeImg.src = href;
//     largeImg.alt = title;
//
//     // .src - ссылка на изображение.
//     // .alt - текст картинки.
//
// }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Генерация пользовательских событий
// Можно не только назначать обработчики, но и генерировать события из JavaScript-кода.

// Пользовательские события могут быть использованы при создании графических компонентов. Например, корневой элемент нашего меню, реализованного при помощи JavaScript, может генерировать события, относящиеся к этому меню: open (меню раскрыто), select (выбран пункт меню) и т.п. А другой код может слушать эти события и узнавать, что происходит с меню.

// Можно генерировать не только совершенно новые, придуманные нами события, но и встроенные, такие как click, mousedown и другие. Это бывает полезно для автоматического тестирования.

// Конструктор Event
// Встроенные классы для событий формируют иерархию аналогично классам для DOM-элементов. Её корнем является встроенный класс Event.

// Событие встроенного класса Event можно создать так:

// let event = new Event(type[, options]);
// Где:

    // type – тип события, строка, например "click" или же любой придуманный нами – "my-event".
    // options – объект с тремя необязательными свойствами:
    // bubbles: true/false – если true, тогда событие всплывает.
    // cancelable: true/false – если true, тогда можно отменить действие по умолчанию. Позже мы разберём, что это значит для пользовательских событий.
    // composed: true/false – если true, тогда событие будет всплывать наружу за пределы Shadow DOM. Позже мы разберём это в разделе Веб-компоненты.
    // По умолчанию все три свойства установлены в false: {bubbles: false, cancelable: false, composed: false}.

// Метод dispatchEvent
// После того, как объект события создан, мы должны запустить его на элементе, вызвав метод elem.dispatchEvent(event).

// Затем обработчики отреагируют на него, как будто это обычное браузерное событие. Если при создании указан флаг bubbles,
// то оно будет всплывать.

// В примере ниже событие click инициируется JavaScript-кодом так, как будто кликнули по кнопке:

    // let event = new Event("click");
    // elem.dispatchEvent(event);

// event.isTrusted
// Можно легко отличить «настоящее» событие от сгенерированного кодом.

// Свойство event.isTrusted принимает значение true для событий, порождаемых реальными действиями пользователя, и false для
// генерируемых кодом.

// Пример всплытия
// Мы можем создать всплывающее событие с именем "hello" и поймать его на document.

    // Всё, что нужно сделать – это установить флаг bubbles в true:

    // ловим на document...
//     document.addEventListener("hello", function(event) { // (1)
//     alert("Привет от " + event.target.tagName); // Привет от H1
// });
//
//     // ...запуск события на элементе!
//     let event = new Event("hello", {bubbles: true}); // (2)
//     elem.dispatchEvent(event);

    // обработчик на document сработает и выведет сообщение.


// Обратите внимание:

// Мы должны использовать addEventListener для наших собственных событий, т.к. on<event>-свойства существуют только для
// встроенных событий, то есть document.onhello не сработает.
// Мы обязаны передать флаг bubbles:true, иначе наше событие не будет всплывать.
// Механизм всплытия идентичен как для встроенного события (click), так и для пользовательского события (hello).
// Также одинакова работа фаз всплытия и погружения.

// MouseEvent, KeyboardEvent и другие
// Для некоторых конкретных типов событий есть свои специфические конструкторы. Вот небольшой список конструкторов для различных событий пользовательского интерфейса, которые можно найти в спецификации UI Event:

// UIEvent
// FocusEvent
// MouseEvent
// WheelEvent
// KeyboardEvent
// …

// Стоит использовать их вместо new Event, если мы хотим создавать такие события. К примеру, new MouseEvent("click").

// Специфический конструктор позволяет указать стандартные свойства для данного типа события.

// Например, clientX/clientY для события мыши:

// let event = new MouseEvent("click", {
//     bubbles: true,
//     cancelable: true,
//     clientX: 100,
//     clientY: 100
// });
//
// alert(event.clientX); // 100

// Обратите внимание: этого нельзя было бы сделать с обычным конструктором Event.

// Давайте проверим:

// let event = new Event("click", {
//     bubbles: true, // только свойства bubbles и cancelable
//     cancelable: true, // работают в конструкторе Event
//     clientX: 100,
//     clientY: 100
// });
//
// alert(event.clientX); // undefined, неизвестное свойство проигнорировано!

// Впрочем, использование конкретного конструктора не является обязательным, можно обойтись Event, а свойства записать
// в объект отдельно, после создания, вот так: event.clientX=100. Здесь это скорее вопрос удобства и желания следовать правилам.
// События, которые генерирует браузер, всегда имеют правильный тип.
// Полный список свойств по типам событий вы найдёте в спецификации, например, MouseEvent.

